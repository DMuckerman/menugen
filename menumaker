#!/bin/bash

# Internal values
declare -ga prevmenu=("")
declare -ga prevname=("")
currentmenu="main"
scriptname="$1"

# Special vars defined for each menu
declare -ga ITEMID
declare -gA ITEMNAME
declare -gA ITEMTYPE
declare -gA ITEMLINK
declare -gA ITEMACTION
name=""
prompt=""
numbered=true
autoselect=true
back=true

# Function which adds ITEMs to the menu
# $1 - ITEM name
# $2 - Link location
# $3 - Action to perform on follow
function add_item() {
	local hash=$(echo "$1" | md5sum | cut -d' ' -f 1)
	# TODO: check parameters provided
	if [[ "$1" == "" ]]; then
		echo "ERROR: ITEM name must not be blank!"
		exit -1
	fi
	if [[ "$#" -lt 2 ]]; then
		echo "ERROR: add_item requires at least two parameters"
		exit -1
	fi
	ITEMID+=("$hash")
	ITEMNAME["$hash"]="$1"
	ITEMTYPE["$hash"]="item"
	ITEMLINK["$hash"]="$2"
	ITEMACTION["$hash"]="$3"
}

# Function which adds BACK to the menu
# TODO: $1 - Custom back text
# TODO: $2 - Custom back link
function add_back() {
	local item_text=""
	# No args provided, auto generate back item
	if [[ "$#" -eq 0 ]]; then
		if [[ "${prevmenu[-1]}" == "" ]]; then
			item_text="< Exit"
		else
			item_text="< Back to ${prevname[-1]}"
		fi
	fi
	local hash=$(echo "$item_text" | md5sum | cut -d' ' -f 1)
	ITEMID+=("$hash")
	ITEMNAME["$hash"]="$item_text"
	ITEMTYPE["$hash"]="back"
	ITEMLINK["$hash"]="${prevmenu[-1]}"
	# ITEMACTION["$hash"]="exit"
}

# Function which adds NOPs to the menu
# $1 - nop text
# TODO: maybe add the ability to make NOPs run commands
function add_nop() {
	if [[ "$#" -ne 1 ]]; then
		echo "ERROR: add_nop requires the item text"
		exit -1
	fi
	local hash=$(echo "$1" | md5sum | cut -d' ' -f 1)
	ITEMID+=("$hash")
	ITEMNAME["$hash"]="$1"
	ITEMTYPE["$hash"]="nop"
}

# Test the $1 script is provided
if [[ "$#" -ne 1 ]]; then
		echo "ERROR: menumaker requires a menumaker script as it's parameter"
		exit -1
fi
if [ ! -e $scriptname ]; then
		echo "ERROR: The script $scriptname does not exist"
		exit -1
fi

# Fucntion to test if the menu $1 is defined in the menu script
# TODO: test if begin comes before end, whether begin pattern exists, and verify there is only one of each begin and end statement in the menuscript
function testForMenu() {
		menu="$1"

		# Test to make sure an end pattern exists, sed will just keep on chomping till the EOF otherwise
		grep "#end $menu" $scriptname > /dev/null
		if [[ $? -ne 0 ]]; then
				echo "ERROR: Menu $menu is missing #end statement"
				exit -1
		fi

		# See if a block exists
		ret=$(sed -n "/#begin $menu/,/#end $menu/p" $scriptname | wc -l)
		if [[ $ret -eq 0 ]]; then
				echo "ERROR: Menu $menu doesn't exist"
				exit -1
		fi
}

# Function to reset all the values to their defaults to keep the menu system working cleanly
function resetEverythingToDefault() {
	unset ITEMID
	unset ITEMNAME
	unset ITEMTYPE
	unset ITEMLINK
	unset ITEMACTION
	declare -ga ITEMID
	declare -gA ITEMNAME
	declare -gA ITEMTYPE
	declare -gA ITEMLINK
	declare -gA ITEMACTION
	name=""
	prompt=""
	numbered=true
	autoselect=true
	back=true
}

# Function to reset all the values to their defaults to keep the menu system working cleanly
function resetVarsToDefault() {
	name=""
	prompt=""
	numbered=true
	autoselect=true
	back=true
}

while [ "$currentmenu" != "" ]; do
	ROFIMENU=""

	resetEverythingToDefault

	# Add autogenerated back if necessary
	if [[ $back == true ]]; then
		add_back
		add_nop "---"
	fi

	# Load current menu
	testForMenu $currentmenu
	source <(sed -n "/#begin $currentmenu/,/#end $currentmenu/p" $scriptname)

	# Generate a prompt if one does not exist
	if [[ "$prompt" == "" ]]; then
		echo "$name > "
		prompt="$name > "
	fi

	num=1
	for key in "${ITEMID[@]}"; do
		item="${ITEMNAME[$key]}"
		if [[ "${ITEMTYPE[$key]}" == item ]]; then
			if [[ $numbered == true ]]; then
				ROFIMENU+="$num $item\n"
				((num++))
			else
				ROFIMENU+="$item\n"
			fi
		else
			ROFIMENU+="$item\n"
		fi
	done

	# RUN ROFI!
	result=$(echo -e "$ROFIMENU" | rofi -dmenu -p "$prompt")
	# If nothing was returned, the user quit
	if [[ "$result" == "" ]]; then
		break
	else
		# Otherwise, remove the number if added
		if [[ $numbered = true ]]; then
			sanatized=$(echo $result | sed 's/^[0-9]\+ //g')
		else
			sanatized=$result
		fi
		# Calculate the lookup key
		key=$(echo "$sanatized" | md5sum | cut -d' ' -f 1)
		# Then lookup our next action
		if [[ ${ITEMTYPE["$key"]} == "nop" ]]; then
			continue
		elif [[ ${ITEMTYPE["$key"]} == "item" ]]; then
			prevmenu+=("$currentmenu")
			prevname+=("$name")
			currentmenu=${ITEMLINK["$key"]}
		elif [[ ${ITEMTYPE["$key"]} == "back" ]]; then
			currentmenu=${prevmenu[-1]}
			unset prevmenu[${#prevmenu[@]}-1]
			unset prevname[${#prevname[@]}-1]
		else
			echo "ERROR: Invalid ITEM type"
		fi
	fi
done

